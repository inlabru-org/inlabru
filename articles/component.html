<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Defining model components • inlabru</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Defining model components">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">inlabru</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.11.1.9015</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-general-examples" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">General examples</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-general-examples">
<li><h6 class="dropdown-header" data-toc-skip>Basic examples</h6></li>
    <li><a class="dropdown-item" href="../articles/random_fields.html">Random field models in 1D</a></li>
    <li><a class="dropdown-item" href="../articles/random_fields_2d.html">Spatial random field models in 2D</a></li>
    <li><a class="dropdown-item" href="../articles/publications.html">Publications</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Concepts</h6></li>
    <li><a class="dropdown-item" href="../articles/component.html">Defining a model component</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Special models and techniques</h6></li>
    <li><a class="dropdown-item" href="../articles/svc.html">Spatially varying coefficient models</a></li>
    <li><a class="dropdown-item" href="../articles/zip_zap_models.html">ZIP and ZAP count models (zero-inflation)</a></li>
    <li><a class="dropdown-item" href="../articles/prediction_scores.html">Computing posterior prediction scores</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../articles/articles.html">Full articles list</a></li>
  </ul>
</li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-point-processes" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Point processes</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-point-processes">
<li><h6 class="dropdown-header" data-toc-skip>Point process examples</h6></li>
    <li><a class="dropdown-item" href="../articles/1d_lgcp.html">LGCPs - An example in one dimension</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp.html">LGCPs - An example in two dimensions (sf version)</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_sp.html">LGCPs - An example in two dimensions (sp version)</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_covars.html">LGCPs - Spatial covariates</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_distancesampling.html">LGCPs - Distance sampling</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_plotsampling.html">LGCPs - Plot sampling</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_multilikelihood.html">LGCPs - Multiple likelihoods</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_spatiotemporal.html">LGCPs - An example in space and time</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_residuals_sf.html">LGCPs - Residuals (sf version)</a></li>
    <li><a class="dropdown-item" href="../articles/2d_lgcp_residuals.html">LGCPs - Residuals (sp version)</a></li>
  </ul>
</li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-technical-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Technical articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-technical-articles">
<li><h6 class="dropdown-header" data-toc-skip>Mapper techniques</h6></li>
    <li><a class="dropdown-item" href="../articles/bru_mapper.html">Customised model component with the bru_mapper system</a></li>
    <li><a class="dropdown-item" href="../articles/mesh_mapping.html">Converting inla.spde.make.A calls to the bru_mapper system</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Theory and technical documentation</h6></li>
    <li><a class="dropdown-item" href="../articles/Apptainer.html">Installation of INLA and inlabru with Apptainer on HPC</a></li>
    <li><a class="dropdown-item" href="../articles/method.html">The iterative linearised inlabru method</a></li>
    <li><a class="dropdown-item" href="../articles/linearapprox.html">A nonlinear model approximation example</a></li>
    <li><a class="dropdown-item" href="../articles/devel_flow.html">Code internal flow diagrams for model evaluation</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/inlabru-org/inlabru/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Defining model components</h1>
                        <h4 data-toc-skip class="author">Andy
Seaton</h4>
            
            <h4 data-toc-skip class="date">Generated on 2024-10-15</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/inlabru-org/inlabru/blob/devel/vignettes/component.Rmd" class="external-link"><code>vignettes/component.Rmd</code></a></small>
      <div class="d-none name"><code>component.Rmd</code></div>
    </div>

    
    
<p>(Note: vignette under construction!)</p>
<div class="section level2">
<h2 id="basic-component-features">Basic component features<a class="anchor" aria-label="anchor" href="#basic-component-features"></a>
</h2>
<p>Model components are defined using a formula syntax that is similar
to <code>R-INLA</code> but has some differences. The basic syntax is</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_component_name</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="va">...</span>,</span>
<span>  model <span class="op">=</span> <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><code>my_component_name</code> is a user-chosen label for the model
component. This label is used in model summaries, to label relevant
parts of a fitted model object, and to access model components when
sampling from a model using <code><a href="../reference/generate.html">generate()</a></code> and
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>.</p>
<p>The <code>main</code> argument defines the input data for the
component. For example, an intercept-like component has a vector of ones
as an input. The linear effect of a covariate has the vector of
covariate values as an input. A 2-dimensional SPDE effect takes a
2-column matrix of coordinate locations as an input. This argument can
be a general <code>R</code> expression, more details on this are below.
The <code>main</code> argument doesn’t not need to be named. Other
arguments should normally be named, to avoid confusion.</p>
<p>The type of model component is specified using the <code>model</code>
component, (see <code><a href="../reference/component.html">?component</a></code>, and
<code>?INLA::inla.list.models()$latent</code>).</p>
<p>Each component type has an associated <code>bru_mapper</code> method
that takes <code>main</code> as an input and constructs the component
design matrix. Users can also specify their own mapper methods (see
<code><a href="../reference/bru_mapper.html">?bru_mapper</a></code>).</p>
<p>This syntax replaces the <code><a href="https://rdrr.io/pkg/INLA/man/f.html" class="external-link">INLA::f()</a></code> function that has the
disadvantage that there is no clear separation between the name of the
covariate and the label of the effect, and the user often has to do a
substantial amount of pre-processing of data to construct relevant
inputs. The documentation for defining model components can be viewed at
<code><a href="../reference/component.html">?component</a></code>.</p>
<p>The rest of the vignette goes into more detail about defining model
components and highlights some advantages of the syntax.</p>
</div>
<div class="section level2">
<h2 id="what-is-a-component-design-matrix">What is a component design matrix?<a class="anchor" aria-label="anchor" href="#what-is-a-component-design-matrix"></a>
</h2>
<p>A linear additive predictor of a latent Gaussian model can be written
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>i</mi></msub><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>a</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
\begin{equation}
\eta(u)_i = u_0 + \sum_{k=1}^K a_{ik} u_{ik} ,
\end{equation}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
is a multivariate Gaussian vector,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>k</mi></msub><annotation encoding="application/x-tex">a_k</annotation></semantics></math>
are input information such as covariates or weights for random effects
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math>.
This can also be written as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>A</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">\eta(u) = Au</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is the model design matrix with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
row
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>K</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\left[1, a_{i1}, \ldots, a_{iK}\right]</annotation></semantics></math>.</p>
<p>We can also conceptally think of the predictor as the sum of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
model components, so that we partition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>⋯</mi><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>D</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">A = \left[A^{(1)} \cdots A^{(D)}\right]</annotation></semantics></math>,
and each component has an associated <strong>component design
matrix</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">A^{(d)}</annotation></semantics></math>.</p>
<p>For example, if the component is an intercept parameter, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>⊺</mo></msup></mrow><annotation encoding="application/x-tex">A^{(d)} = \left[1, \ldots, 1\right]^\intercal</annotation></semantics></math>.
If the component is the linear effect of a covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>⊺</mo></msup></mrow><annotation encoding="application/x-tex">A^{(d)} = \left[z_1, \ldots, z_n\right]^\intercal</annotation></semantics></math>.
For more complicated effects, such as SPDE models, the component design
matrix maps latent Gaussian parameters to the predictor (also known as
the “projector” matrix in this context). The the construction of each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">A^{(d)}</annotation></semantics></math>
is handled automatically by <code>bru_mapper</code> methods, that define
general (linear) <strong>component effects</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>η</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><msup><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\eta^{(d)}(u^{(d)}) = A^{(d)} u^{(d)}</annotation></semantics></math>.</p>
<p>Each linear predictor is defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><mi>…</mi><mo>,</mo><msup><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>D</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>d</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><msup><mi>η</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>d</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><msup><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
\eta(u^{(1)},\dots,u^{(D)}) = \sum_{d=1}^D \eta^{(d)}(u^{(d)}) = \sum_{d=1}^D A^{(d)} u^{(d)} .
</annotation></semantics></math> Non-linear predictors are defined by R
expressions where the component label denotes the corresponding
component effect.</p>
<div class="section level3">
<h3 id="mapper-methods">Mapper methods<a class="anchor" aria-label="anchor" href="#mapper-methods"></a>
</h3>
<p>Each component type has an associated method for converting the
information given in the component definition into a component design
matrix. The full model design matrix is then used internally in a call
<code><a href="https://rdrr.io/pkg/INLA/man/inla.html" class="external-link">INLA::inla()</a></code> to fit the model.</p>
<p>The advantage of specifying mapper methods is that it supports
automatic ‘stack building’. A key feature of <code>inlabru</code> is
that the full model stack is constructed automatically from the
component definitions. The building blocks of the stack are built using
<code>bru_mapper</code> methods.</p>
<div class="section level4">
<h4 id="mapper-example-2d-spde">Mapper example: 2D SPDE<a class="anchor" aria-label="anchor" href="#mapper-example-2d-spde"></a>
</h4>
<p>The mapper for the 2D SPDE effect takes as an input a 2-column matrix
of coordinates that represent the locations are which to evaluate the
effect. The parameters of the SPDE component are defined at mesh nodes
that may not be the same as the locations at which the effect should be
evaluated.</p>
<p>The appropriate weights required to evaluate the effect at the
observation locations can be constructed using
<code><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluator()</a></code>. The mapper for this model component takes
the information in the component definition, in this case the minimum
information required is an SPDE model object, and the 2-column matrix
that <code>main</code> is evaluated to. The mapper then calls
<code><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluator()</a></code> with appropriate arguments extracted from
this information.</p>
<p>(NOTE: Deliberately not going into huge detail here; the <a href="bru_mapper.html">bru_mapper</a> vignette will have more
details.)</p>
</div>
</div>
<div class="section level3">
<h3 id="defining-main-group-and-replicate-">Defining <code>main</code>, <code>group</code>, and
<code>replicate</code>.<a class="anchor" aria-label="anchor" href="#defining-main-group-and-replicate-"></a>
</h3>
<p>The arguments <code>main</code>, <code>group</code>, and
<code>replicate</code> can all take a general <code>R</code> expression
as an input. This expression is then evaluated in an environment that
consists of the named variables in the data (note: for <code>sp</code>
objects this does <em>not</em> include the column names from the
<code>@coords</code> slot, but does include the columns in
<code>@data</code>).</p>
<p>If the names are not found in the data then the global environment is
searched for objects of that name.</p>
<p>For example, suppose the data has columns named <code>x</code> and
<code>y</code>, then a 2D SPDE model component could be specified as</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_spde_effect</span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="va">spde_model</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The expression <code>cbind(x,y)</code> is internally evaluated in an
environment that contains the columns of the data, which includes the
variables <code>x</code> and <code>y</code>.</p>
<p>The full data object can be accessed using the <code>.data.</code>
key-word. An equivalent way to define the same component is</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">get_xy</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">x</span>, <span class="va">df</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="op">~</span> <span class="fu">my_spde_effect</span><span class="op">(</span></span>
<span>  <span class="fu">get_xy</span><span class="op">(</span><span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="va">spde_model</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This keyword allows code to be written that works with arbitrarily
named input data, rather than hardcoding with a specific name of a
dataset that may change in future.</p>
<p>If the objects required to evaluate the R expression cannot be found
in the data, then the global environment is searched. This allows users
to access objects in the global environment, such as other
data-structures that may be of a different dimension to the response
data. This avoids the need to pre-process everything into a single
<code>data.frame</code>.</p>
<p>The functionality of allowing general <code>R</code> expressions can
be used to extend the types of data that can be passed to the
<code><a href="../reference/bru.html">bru()</a></code>, <code><a href="../reference/bru_like.html">like()</a></code> and <code><a href="../reference/lgcp.html">lgcp()</a></code>
functions. It is the basis for the support of spatial data structures
such as <code>sp</code> objects, and there is also experimental support
to allow users to pass data as a list. <code>inlabru</code> is thus
readily extendible, given appropriate functions to extract the relevant
information for each component, and associated mappers that convert this
information into a component design matrix.</p>
<p>In addition to the three main inputs, the optional
<code>weights</code> argument also takes an R expression, and the result
is used to scale the component. This can be used for spatially varying
coefficient models, where the <code>weights</code> argument provides the
covariate values.</p>
</div>
<div class="section level3">
<h3 id="inlabru-specific-component-types">
<code>inlabru</code>-specific component types<a class="anchor" aria-label="anchor" href="#inlabru-specific-component-types"></a>
</h3>
<p>In addition to the majority of latent models that can be defined
using <code><a href="https://rdrr.io/pkg/INLA/man/f.html" class="external-link">INLA::f()</a></code> function (see
<code>INLA::inla.list.models()$latent)</code>), <code>inlabru</code>
also has the following models: <code>'linear'</code>,
<code>'fixed'</code>, <code>'offset'</code>, <code>'factor_full'</code>
and <code>'factor_contrast'</code>).</p>
<!--
(NOTE: where should we put some documentation for these things? Some is in `?component` but not all.  I could add to that?
And can we implement an `inlabru.list.models()` function?)
-->
</div>
</div>
<div class="section level2">
<h2 id="shortcuts">Shortcuts<a class="anchor" aria-label="anchor" href="#shortcuts"></a>
</h2>
<p>There are a few shortcuts to defining model components. They are
for</p>
<ol style="list-style-type: decimal">
<li>Parameters that are the same for all predictor evaluations
(intercept-like parameters).</li>
<li>Using a covariate stored in an <code>sp</code> <code>Spatial*</code>
or <code>terra</code> <code>SpatRaster</code> object.</li>
<li>Defining linear effects using an <code>lm</code>-style syntax.</li>
<li>Behaviour for if <code>main</code>, <code>group</code> or
<code>replicate</code> is a function given with no arguments.</li>
</ol>
<div class="section level3">
<h3 id="intercept-like-components">Intercept-like components<a class="anchor" aria-label="anchor" href="#intercept-like-components"></a>
</h3>
<p>The syntax</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_intercept</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>can be used as a shortcut for</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_intercept</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"linear"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>where <code>n</code> is the length of the predictor vector. Note that
this shortcut makes an assumption about the approriate length of the
predictor. For many models this can be easily deduced by inspecting
input data, but this is not always the case, for example if the response
and covariate data are of different dimensions or for joint likelihood
models with shared components.</p>
</div>
<div class="section level3">
<h3 id="spatial-covariates">Spatial covariates<a class="anchor" aria-label="anchor" href="#spatial-covariates"></a>
</h3>
<p>If <code>main</code>, <code>group</code>, or <code>replicate</code>,
is the name of an <code>sf</code>, <code>SpatRaster</code>, or
<code>Spatial*</code> object stored in the global <code>R</code>
environment, then <code>inlabru</code> attempts to do something
intelligent by extracting the covariate information at the locations of
the data passed to <code><a href="../reference/bru.html">bru()</a></code> or <code><a href="../reference/bru_like.html">like()</a></code>. This
<strong>requires that this data is a <code>sf</code> or
<code>SpatialPoints*</code> object</strong>. <code>inlabru</code> does
this by calling the <code><a href="../reference/eval_spatial.html">inlabru::eval_spatial()</a></code> method, which
supports several covariate storage types.</p>
<p>The shortcut</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_sp_effect</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="va">a_spatial_object</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"linear"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>internally calls <code><a href="../reference/eval_spatial.html">eval_spatial()</a></code> which equivalent to</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_sp_effect</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu"><a href="../reference/eval_spatial.html">eval_spatial</a></span><span class="op">(</span><span class="va">a_spatial_object</span>, <span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"linear"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Note that this requires <code>a_spatial_object</code> to be stored in
the global <code>R</code> environment (or in the environment associated
with the model definition code) so it is findable when the expression is
internally evaluated by <code>inlabru</code>. Also note that the
<code><a href="../reference/eval_spatial.html">eval_spatial()</a></code> function by default extracts the first
column of the raster object. For more general situations, one can either
specify the optional <code>main_layer</code> argument to extract another
named or indexed column, or directly use
<code>main = eval_spatial(a_spatial_object, .data., layer = some_layer)</code>.</p>
<p>Note that this assumes that the data is either <code>sf</code>, so
that <code>st_geometry(.data.)</code> retrieves point locations, or
<code>sp</code> where <code>coordinates(.data.)</code> retrieves
coordinates. This might not be a sensible thing for all models! For
example, if the input data is a <code>SpatialPolygonsDataFrame</code>
then <code>coordinates(.data.)</code> returns the centroid of each
polygon. As more specific input type support is developed, and support
for <code>sp</code> is gradually deprecated in favour of <code>sf</code>
and <code>terra</code>, these special cases may be given more precise
meaning. For example, the <code>a_spatial_object</code> above may be an
<code>sf</code> or <code>sp</code> polygon object with data columns,
which is interpreted as a spatially piecewise constant covariate.</p>
</div>
<div class="section level3">
<h3 id="lm-style-fixed-effect-and-interaction-syntax">
<code>lm</code>-style fixed effect and interaction syntax<a class="anchor" aria-label="anchor" href="#lm-style-fixed-effect-and-interaction-syntax"></a>
</h3>
<p>Since <code>inlabru</code> version 2.5.0, a feature has been added to
allow users to specify linear fixed effects using a formula as input.
This uses the <code>model = 'fixed'</code> component type. The basic
component input is a model matrix. Alternatively, one can supply a
formula specification, which is then used to generate a model matrix
automatically, with
<code>MatrixModels::model.Matrix(formula, data = .data.)</code>. If you
want a different kind of model matrix construction, replace
<code>~ x1 + x2</code> by some other R code that generates the needed
matrix, using the <code>.data.</code> object as input.</p>
<p>Example syntax:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_fixed_effects</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="op">~</span> <span class="va">x1</span><span class="op">:</span><span class="va">x2</span> <span class="op">+</span> <span class="va">x3</span> <span class="op">*</span> <span class="va">x4</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"fixed"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>which is equvalent to</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_fixed_effects</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu">MatrixModels</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/MatrixModels/man/model.Matrix.html" class="external-link">model.Matrix</a></span><span class="op">(</span><span class="op">~</span> <span class="va">x1</span><span class="op">:</span><span class="va">x2</span> <span class="op">+</span> <span class="va">x3</span> <span class="op">*</span> <span class="va">x4</span>, <span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"fixed"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>where the data has columns named <code>x1</code>, <code>x2</code>,
<code>x3</code>, and <code>x4</code>.</p>
<p>This allows users to define interactions in a concise way, by
utilising the functionality already supported by the
<code>MatrixModels</code> package. The formula is interpreted in the
conventional way, <code>x1:x2</code> is the interaction of covariates
<code>x1</code> and <code>x2</code>, not including their individual
fixed effects, and <code>x3 * x4</code> is the interaction of
<code>x3</code> and <code>x4</code> inclusive of the individual fixed
effects <code>x3</code> and <code>x4</code>. Note that for
implementation technical reasons, the estimated parameters appear in
<code>'summary.random'</code> instead of the normal
<code>'summary.fixed'</code> part of the
<code>inla</code>/<code>bru</code> output object.</p>
<p>The alternative to using this shortcut would be for the user to
define and name individual components for each term in the formula.</p>
</div>
<div class="section level3">
<h3 id="a-function-given-with-no-arguments">A function given with no arguments<a class="anchor" aria-label="anchor" href="#a-function-given-with-no-arguments"></a>
</h3>
<p>If <code>main</code>, <code>group</code>, or <code>replicate</code>
are given as a function with no covariates, then this function is
applied to the data. For example,</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">a_component</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="va">a_function</span>,</span>
<span>  model <span class="op">=</span> <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>is equivalent to</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">a_component</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu">a_function</span><span class="op">(</span><span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="non-linear-predictors">Non-linear predictors<a class="anchor" aria-label="anchor" href="#non-linear-predictors"></a>
</h3>
<p><code>inlabru</code> supports non-linear predictors, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>η</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tilde{\eta}(u,v)</annotation></semantics></math>
is a non-linear function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>u</mi></msub><annotation encoding="application/x-tex">\eta_u</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\eta_v</annotation></semantics></math>.
It is important to note that the mapping each component effect vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>u</mi></msub><mo>=</mo><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>u</mi></mrow><annotation encoding="application/x-tex">\eta_u=A^{(u)} u</annotation></semantics></math>
happens <strong>before</strong> the non-linear function is applied. So,
for example, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>η</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>u</mi></msub><mo>+</mo><msub><mi>η</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tilde{\eta}(u,v) = \exp(\eta_u + \eta_v)</annotation></semantics></math>
then this is evaluated as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>u</mi><mo>+</mo><msup><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\exp(A^{(u)} u + A^{(v)} v)</annotation></semantics></math>.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Finn Lindgren, Fabian E. Bachl.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
