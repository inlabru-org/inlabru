<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="inlabru">
<title>Defining model components • inlabru</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Defining model components">
<meta property="og:description" content="inlabru">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">inlabru</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.10.1.9003</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-general-examples">General examples</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-general-examples">
    <h6 class="dropdown-header" data-toc-skip>Basic examples</h6>
    <a class="dropdown-item" href="../articles/random_fields.html">Random field models in 1D</a>
    <a class="dropdown-item" href="../articles/random_fields_2d.html">Spatial random field models in 2D</a>
    <a class="dropdown-item" href="../articles/publications.html">Publications</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Concepts</h6>
    <a class="dropdown-item" href="../articles/component.html">Defining a model component</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Special models and techniques</h6>
    <a class="dropdown-item" href="../articles/svc.html">Spatially varying coefficient models</a>
    <a class="dropdown-item" href="../articles/zip_zap_models.html">ZIP and ZAP count models (zero-inflation)</a>
    <a class="dropdown-item" href="../articles/prediction_scores.html">Computing posterior prediction scores</a>
    <div class="dropdown-divider"></div>
    <a class="dropdown-item" href="../articles/articles.html">Full articles list</a>
  </div>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-point-processes">Point processes</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-point-processes">
    <h6 class="dropdown-header" data-toc-skip>Point process examples</h6>
    <a class="dropdown-item" href="../articles/1d_lgcp.html">LGCPs - An example in one dimension</a>
    <a class="dropdown-item" href="../articles/2d_lgcp.html">LGCPs - An example in two dimensions (sp version)</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_sf.html">LGCPs - An example in two dimensions (sf version)</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_covars.html">LGCPs - Spatial covariates</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_distancesampling.html">LGCPs - Distance sampling</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_plotsampling.html">LGCPs - Plot sampling</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_multilikelihood.html">LGCPs - Multiple likelihoods</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_spatiotemporal.html">LGCPs - An example in space and time</a>
    <a class="dropdown-item" href="../articles/2d_lgcp_residuals.html">LGCPs - Residuals</a>
  </div>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-technical-articles">Technical articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-technical-articles">
    <h6 class="dropdown-header" data-toc-skip>Mapper techniques</h6>
    <a class="dropdown-item" href="../articles/bru_mapper.html">Customised model component with the bru_mapper system</a>
    <a class="dropdown-item" href="../articles/mesh_mapping.html">Converting inla.spde.make.A calls to the bru_mapper system</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Theory and technical documentation</h6>
    <a class="dropdown-item" href="../articles/Apptainer.html">Installation of INLA and inlabru with Apptainer on HPC</a>
    <a class="dropdown-item" href="../articles/method.html">The iterative linearised inlabru method</a>
    <a class="dropdown-item" href="../articles/linearapprox.html">A nonlinear model approximation example</a>
    <a class="dropdown-item" href="../articles/devel_flow.html">Code internal flow diagrams for model evaluation</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/inlabru-org/inlabru/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Defining model components</h1>
                        <h4 data-toc-skip class="author">Andy
Seaton</h4>
            
            <h4 data-toc-skip class="date">Generated on 2024-04-16</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/inlabru-org/inlabru/blob/HEAD/vignettes/component.Rmd" class="external-link"><code>vignettes/component.Rmd</code></a></small>
      <div class="d-none name"><code>component.Rmd</code></div>
    </div>

    
    
<p>(Note: vignette under construction!)</p>
<div class="section level2">
<h2 id="basic-component-features">Basic component features<a class="anchor" aria-label="anchor" href="#basic-component-features"></a>
</h2>
<p>Model components are defined using a formula syntax that is similar
to <code>R-INLA</code> but has some differences. The basic syntax is</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_component_name</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="va">...</span>,</span>
<span>  model <span class="op">=</span> <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><code>my_component_name</code> is a user-chosen label for the model
component. This label is used in model summaries, to label relevant
parts of a fitted model object, and to access model components when
sampling from a model using <code><a href="../reference/generate.html">generate()</a></code> and
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>.</p>
<p>The <code>main</code> argument defines the input data for the
component. For example, an intercept-like component has a vector of ones
as an input. The linear effect of a covariate has the vector of
covariate values as an input. A 2-dimensional SPDE effect takes a
2-column matrix of coordinate locations as an input. This argument can
be a general <code>R</code> expression, more details on this are below.
The <code>main</code> argument doesn’t not need to be named. Other
arguments should normally be named, to avoid confusion.</p>
<p>The type of model component is specified using the <code>model</code>
component, (see <code><a href="../reference/component.html">?component</a></code>, and
<code>?INLA::inla.list.models()$latent</code>).</p>
<p>Each component type has an associated <code>bru_mapper</code> method
that takes <code>main</code> as an input and constructs the component
design matrix. Users can also specify their own mapper methods (see
<code><a href="../reference/bru_mapper.html">?bru_mapper</a></code>).</p>
<p>This syntax replaces the <code><a href="https://rdrr.io/pkg/INLA/man/f.html" class="external-link">INLA::f()</a></code> function that has the
disadvantage that there is no clear separation between the name of the
covariate and the label of the effect, and the user often has to do a
substantial amount of pre-processing of data to construct relevant
inputs. The documentation for defining model components can be viewed at
<code><a href="../reference/component.html">?component</a></code>.</p>
<p>The rest of the vignette goes into more detail about defining model
components and highlights some advantages of the syntax.</p>
</div>
<div class="section level2">
<h2 id="what-is-a-component-design-matrix">What is a component design matrix?<a class="anchor" aria-label="anchor" href="#what-is-a-component-design-matrix"></a>
</h2>
<p>A linear additive predictor of a latent Gaussian model can be written
as <span class="math display">\[
\begin{equation}
\eta(u)_i = u_0 + \sum_{k=1}^K a_{ik} u_{ik} ,
\end{equation}
\]</span> where <span class="math inline">\(u\)</span> is a multivariate
Gaussian vector, <span class="math inline">\(a_k\)</span> are input
information such as covariates or weights for random effects and <span class="math inline">\(i = 1, \ldots, n\)</span>. This can also be
written as <span class="math inline">\(\eta(u) = Au\)</span>, where
<span class="math inline">\(A\)</span> is the model design matrix with
<span class="math inline">\(i\)</span>-th row <span class="math inline">\(\left[1, a_{i1}, \ldots,
a_{iK}\right]\)</span>.</p>
<p>We can also conceptally think of the predictor as the sum of <span class="math inline">\(D\)</span> model components, so that we partition
<span class="math inline">\(A = \left[A^{(1)} \cdots
A^{(D)}\right]\)</span>, and each component has an associated
<strong>component design matrix</strong> <span class="math inline">\(A^{(d)}\)</span>.</p>
<p>For example, if the component is an intercept parameter, then <span class="math inline">\(A^{(d)} = \left[1, \ldots,
1\right]^\intercal\)</span>. If the component is the linear effect of a
covariate <span class="math inline">\(z\)</span> then <span class="math inline">\(A^{(d)} = \left[z_1, \ldots,
z_n\right]^\intercal\)</span>. For more complicated effects, such as
SPDE models, the component design matrix maps latent Gaussian parameters
to the predictor (also known as the “projector” matrix in this context).
The the construction of each <span class="math inline">\(A^{(d)}\)</span> is handled automatically by
<code>bru_mapper</code> methods, that define general (linear)
<strong>component effects</strong> <span class="math inline">\(\eta^{(d)}(u^{(d)}) = A^{(d)}
u^{(d)}\)</span>.</p>
<p>Each linear predictor is defined by <span class="math display">\[
\eta(u^{(1)},\dots,u^{(D)}) = \sum_{d=1}^D \eta^{(d)}(u^{(d)}) =
\sum_{d=1}^D A^{(d)} u^{(d)} .
\]</span> Non-linear predictors are defined by R expressions where the
component label denotes the corresponding component effect.</p>
<div class="section level3">
<h3 id="mapper-methods">Mapper methods<a class="anchor" aria-label="anchor" href="#mapper-methods"></a>
</h3>
<p>Each component type has an associated method for converting the
information given in the component definition into a component design
matrix. The full model design matrix is then used internally in a call
<code><a href="https://rdrr.io/pkg/INLA/man/inla.html" class="external-link">INLA::inla()</a></code> to fit the model.</p>
<p>The advantage of specifying mapper methods is that it supports
automatic ‘stack building’. A key feature of <code>inlabru</code> is
that the full model stack is constructed automatically from the
component definitions. The building blocks of the stack are built using
<code>bru_mapper</code> methods.</p>
<div class="section level4">
<h4 id="mapper-example-2d-spde">Mapper example: 2D SPDE<a class="anchor" aria-label="anchor" href="#mapper-example-2d-spde"></a>
</h4>
<p>The mapper for the 2D SPDE effect takes as an input a 2-column matrix
of coordinates that represent the locations are which to evaluate the
effect. The parameters of the SPDE component are defined at mesh nodes
that may not be the same as the locations at which the effect should be
evaluated.</p>
<p>The appropriate weights required to evaluate the effect at the
observation locations can be constructed using
<code><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluator()</a></code>. The mapper for this model component takes
the information in the component definition, in this case the minimum
information required is an SPDE model object, and the 2-column matrix
that <code>main</code> is evaluated to. The mapper then calls
<code><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluator()</a></code> with appropriate arguments extracted from
this information.</p>
<p>(NOTE: Deliberately not going into huge detail here; the <a href="bru_mapper.html">bru_mapper</a> vignette will have more
details.)</p>
</div>
</div>
<div class="section level3">
<h3 id="defining-main-group-and-replicate-">Defining <code>main</code>, <code>group</code>, and
<code>replicate</code>.<a class="anchor" aria-label="anchor" href="#defining-main-group-and-replicate-"></a>
</h3>
<p>The arguments <code>main</code>, <code>group</code>, and
<code>replicate</code> can all take a general <code>R</code> expression
as an input. This expression is then evaluated in an environment that
consists of the named variables in the data (note: for <code>sp</code>
objects this does <em>not</em> include the column names from the
<code>@coords</code> slot, but does include the columns in
<code>@data</code>).</p>
<p>If the names are not found in the data then the global environment is
searched for objects of that name.</p>
<p>For example, suppose the data has columns named <code>x</code> and
<code>y</code>, then a 2D SPDE model component could be specified as</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_spde_effect</span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="va">spde_model</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The expression <code>cbind(x,y)</code> is internally evaluated in an
environment that contains the columns of the data, which includes the
variables <code>x</code> and <code>y</code>.</p>
<p>The full data object can be accessed using the <code>.data.</code>
key-word. An equivalent way to define the same component is</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">get_xy</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">x</span>, <span class="va">df</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="op">~</span> <span class="fu">my_spde_effect</span><span class="op">(</span></span>
<span>  <span class="fu">get_xy</span><span class="op">(</span><span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="va">spde_model</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This keyword allows code to be written that works with arbitrarily
named input data, rather than hardcoding with a specific name of a
dataset that may change in future.</p>
<p>If the objects required to evaluate the R expression cannot be found
in the data, then the global environment is searched. This allows users
to access objects in the global environment, such as other
data-structures that may be of a different dimension to the response
data. This avoids the need to pre-process everything into a single
<code>data.frame</code>.</p>
<p>The functionality of allowing general <code>R</code> expressions can
be used to extend the types of data that can be passed to the
<code><a href="../reference/bru.html">bru()</a></code>, <code><a href="../reference/like.html">like()</a></code> and <code><a href="../reference/lgcp.html">lgcp()</a></code>
functions. It is the basis for the support of spatial data structures
such as <code>sp</code> objects, and there is also experimental support
to allow users to pass data as a list. <code>inlabru</code> is thus
readily extendible, given appropriate functions to extract the relevant
information for each component, and associated mappers that convert this
information into a component design matrix.</p>
<p>In addition to the three main inputs, the optional
<code>weights</code> argument also takes an R expression, and the result
is used to scale the component. This can be used for spatially varying
coefficient models, where the <code>weights</code> argument provides the
covariate values.</p>
</div>
<div class="section level3">
<h3 id="inlabru-specific-component-types">
<code>inlabru</code>-specific component types<a class="anchor" aria-label="anchor" href="#inlabru-specific-component-types"></a>
</h3>
<p>In addition to the majority of latent models that can be defined
using <code><a href="https://rdrr.io/pkg/INLA/man/f.html" class="external-link">INLA::f()</a></code> function (see
<code>INLA::inla.list.models()$latent)</code>), <code>inlabru</code>
also has the following models: <code>'linear'</code>,
<code>'fixed'</code>, <code>'offset'</code>, <code>'factor_full'</code>
and <code>'factor_contrast'</code>).</p>
<!--
(NOTE: where should we put some documentation for these things? Some is in `?component` but not all.  I could add to that?
And can we implement an `inlabru.list.models()` function?)
-->
</div>
</div>
<div class="section level2">
<h2 id="shortcuts">Shortcuts<a class="anchor" aria-label="anchor" href="#shortcuts"></a>
</h2>
<p>There are a few shortcuts to defining model components. They are
for</p>
<ol style="list-style-type: decimal">
<li>Parameters that are the same for all predictor evaluations
(intercept-like parameters).</li>
<li>Using a covariate stored in an <code>sp</code> <code>Spatial*</code>
or <code>terra</code> <code>SpatRaster</code> object.</li>
<li>Defining linear effects using an <code>lm</code>-style syntax.</li>
<li>Behaviour for if <code>main</code>, <code>group</code> or
<code>replicate</code> is a function given with no arguments.</li>
</ol>
<div class="section level3">
<h3 id="intercept-like-components">Intercept-like components<a class="anchor" aria-label="anchor" href="#intercept-like-components"></a>
</h3>
<p>The syntax</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_intercept</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>can be used as a shortcut for</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_intercept</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"linear"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>where <code>n</code> is the length of the predictor vector. Note that
this shortcut makes an assumption about the approriate length of the
predictor. For many models this can be easily deduced by inspecting
input data, but this is not always the case, for example if the response
and covariate data are of different dimensions or for joint likelihood
models with shared components.</p>
</div>
<div class="section level3">
<h3 id="spatial-covariates">Spatial covariates<a class="anchor" aria-label="anchor" href="#spatial-covariates"></a>
</h3>
<p>If <code>main</code>, <code>group</code>, or <code>replicate</code>,
is the name of an <code>sf</code>, <code>SpatRaster</code>, or
<code>Spatial*</code> object stored in the global <code>R</code>
environment, then <code>inlabru</code> attempts to do something
intelligent by extracting the covariate information at the locations of
the data passed to <code><a href="../reference/bru.html">bru()</a></code> or <code><a href="../reference/like.html">like()</a></code>. This
<strong>requires that this data is a <code>sf</code> or
<code>SpatialPoints*</code> object</strong>. <code>inlabru</code> does
this by calling the <code><a href="../reference/eval_spatial.html">inlabru::eval_spatial()</a></code> method, which
supports several covariate storage types.</p>
<p>The shorcut</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_sp_effect</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="va">a_spatial_object</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"linear"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>internally calls <code><a href="../reference/eval_spatial.html">eval_spatial()</a></code> which equivalent to</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_sp_effect</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu"><a href="../reference/eval_spatial.html">eval_spatial</a></span><span class="op">(</span><span class="va">a_spatial_object</span>, <span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"linear"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Note that this requires <code>a_spatial_object</code> to be stored in
the global <code>R</code> environment (or in the environment associated
with the model definition code) so it is findable when the expression is
internally evaluated by <code>inlabru</code>. Also note that the
<code><a href="../reference/eval_spatial.html">eval_spatial()</a></code> function by default extracts the first
column of the raster object. For more general situations, one can either
specify the optional <code>main_layer</code> argument to extract another
named or indexed column, or directly use
<code>main = eval_spatial(a_spatial_object, .data., layer = some_layer)</code>.</p>
<p>Note that this assumes that the data is either <code>sf</code>, so
that <code>st_geometry(.data.)</code> retrieves point locations, or
<code>sp</code> where <code>coordinates(.data.)</code> retrieves
coordinates. This might not be a sensible thing for all models! For
example, if the input data is a <code>SpatialPolygonsDataFrame</code>
then <code>coordinates(.data.)</code> returns the centroid of each
polygon. As more specific input type support is developed, and support
for <code>sp</code> is gradually deprecated in favour of <code>sf</code>
and <code>terra</code>, these special cases may be given more precise
meaning. For example, the <code>a_spatial_object</code> above may be an
<code>sf</code> or <code>sp</code> polygon object with data columns,
which is interpreted as a spatially piecewise constant covariate.</p>
</div>
<div class="section level3">
<h3 id="lm-style-fixed-effect-and-interaction-syntax">
<code>lm</code>-style fixed effect and interaction syntax<a class="anchor" aria-label="anchor" href="#lm-style-fixed-effect-and-interaction-syntax"></a>
</h3>
<p>Since <code>inlabru</code> version 2.5.0, a feature has been added to
allow users to specify linear fixed effects using a formula as input.
This uses the <code>model = 'fixed'</code> component type. The basic
component input is a model matrix. Alternatively, one can supply a
formula specification, which is then used to generate a model matrix
automatically, with
<code>MatrixModels::model.Matrix(formula, data = .data.)</code>. If you
want a different kind of model matrix construction, replace
<code>~ x1 + x2</code> by some other R code that generates the needed
matrix, using the <code>.data.</code> object as input.</p>
<p>Example syntax:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_fixed_effects</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="op">~</span> <span class="va">x1</span><span class="op">:</span><span class="va">x2</span> <span class="op">+</span> <span class="va">x3</span> <span class="op">*</span> <span class="va">x4</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"fixed"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>which is equvalent to</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">my_fixed_effects</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu">MatrixModels</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/MatrixModels/man/model.Matrix.html" class="external-link">model.Matrix</a></span><span class="op">(</span><span class="op">~</span> <span class="va">x1</span><span class="op">:</span><span class="va">x2</span> <span class="op">+</span> <span class="va">x3</span> <span class="op">*</span> <span class="va">x4</span>, <span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"fixed"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>where the data has columns named <code>x1</code>, <code>x2</code>,
<code>x3</code>, and <code>x4</code>.</p>
<p>This allows users to define interactions in a concise way, by
utilising the functionality already supported by the
<code>MatrixModels</code> package. The formula is interpreted in the
conventional way, <code>x1:x2</code> is the interaction of covariates
<code>x1</code> and <code>x2</code>, not including their individual
fixed effects, and <code>x3 * x4</code> is the interaction of
<code>x3</code> and <code>x4</code> inclusive of the individual fixed
effects <code>x3</code> and <code>x4</code>. Note that for
implementation technical reasons, the estimated parameters appear in
<code>'summary.random'</code> instead of the normal
<code>'summary.fixed'</code> part of the
<code>inla</code>/<code>bru</code> output object.</p>
<p>The alternative to using this shortcut would be for the user to
define and name individual components for each term in the formula.</p>
</div>
<div class="section level3">
<h3 id="a-function-given-with-no-arguments">A function given with no arguments<a class="anchor" aria-label="anchor" href="#a-function-given-with-no-arguments"></a>
</h3>
<p>If <code>main</code>, <code>group</code>, or <code>replicate</code>
are given as a function with no covariates, then this function is
applied to the data. For example,</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">a_component</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="va">a_function</span>,</span>
<span>  model <span class="op">=</span> <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>is equivalent to</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">~</span> <span class="fu">a_component</span><span class="op">(</span></span>
<span>  main <span class="op">=</span> <span class="fu">a_function</span><span class="op">(</span><span class="va">.data.</span><span class="op">)</span>,</span>
<span>  model <span class="op">=</span> <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="non-linear-predictors">Non-linear predictors<a class="anchor" aria-label="anchor" href="#non-linear-predictors"></a>
</h3>
<p><code>inlabru</code> supports non-linear predictors, where <span class="math inline">\(\tilde{\eta}(u,v)\)</span> is a non-linear
function of <span class="math inline">\(\eta_u\)</span> and <span class="math inline">\(\eta_v\)</span>. It is important to note that the
mapping each component effect vector <span class="math inline">\(\eta_u=A^{(u)} u\)</span> happens
<strong>before</strong> the non-linear function is applied. So, for
example, if <span class="math inline">\(\tilde{\eta}(u,v) = \exp(\eta_u
+ \eta_v)\)</span> then this is evaluated as <span class="math inline">\(\exp(A^{(u)} u + A^{(v)} v)\)</span>.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Finn Lindgren, Fabian E. Bachl.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.8.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
