% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model.R
\name{bru_model}
\alias{bru_model}
\alias{summary.bru_model}
\alias{print.summary_bru_model}
\title{Create an inlabru model object from model components}
\usage{
bru_model(components, lhoods)

\method{summary}{bru_model}(object, ...)

\method{print}{summary_bru_model}(x, ...)
}
\arguments{
\item{components}{A \link{component_list} object}

\item{lhoods}{A list of one or more \code{lhood} objects}

\item{object}{Object to operate on}

\item{\dots}{Arguments passed on to other methods}

\item{x}{A \code{summary_bru_model} object to be printed}
}
\value{
A \link{bru_model} object
}
\description{
The \link{inlabru} syntax for model formulae is different from what
\code{INLA::inla} considers a valid.
In inla most of the effects are defined by adding an \code{f(...)} expression to the formula.
In \link{inlabru} the \code{f} is replaced by an arbitrary (exceptions: \code{const} and \code{offset})
string that will determine the label of the effect. See Details for further information.
}
\details{
For instance

\code{y ~ f(myspde, ...)}

in INLA is equivalent to

\code{y ~ myspde(...)}

in inlabru.

A disadvantage of the inla way is that there is no clear separation between the name of the covariate
and the label of the effect. Furthermore, for some models like SPDE it is much more natural to
use spatial coordinates as covariates rather than an index into the SPDE vertices. For this purpose
\link{inlabru} provides the \code{main} argument. For convenience, the \code{main} argument can be used
like the first argument of the f function, e.g., and is the first argument of the component definition.
The \code{INLA} model formula

\code{y ~ f(temperature, model = 'linear')}

is equivalent to the \code{inlabru} component and formula definition

\code{y ~ temperature(temperature, model = 'linear')}
and
\code{y ~ temperature(main = temperature, model = 'linear')}
as well as
\code{y ~ temperature(model = 'linear')}
which sets \code{main = temperature}.

On the other hand, \code{main} can also be a function mapping, e.g the \code{\link[sp:coordinates]{sp::coordinates()}} function:

\code{y ~ mySPDE(coordinates, ...)}

This extracts the coordinates from the data object, and maps it to the latent
field via the information given in the \code{mapper}, which by default is
extracted from the \code{model} object, in the case of \code{spde} model
objects.

Morevover, \code{main} can be any expression that evaluates within your data as an environment.
For instance, if your data has columns 'a' and 'b', you can create a fixed effect of 'sin(a+b)' by
setting \code{map} in the following way:

\code{y ~ myEffect(sin(a+b))}
}
\keyword{internal}
